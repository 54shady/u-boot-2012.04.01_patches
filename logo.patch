diff -aurNp u-boot-2012.04.01/arch/arm/config.mk u-boot-2012.04.01_logo/arch/arm/config.mk
--- u-boot-2012.04.01/arch/arm/config.mk	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/arch/arm/config.mk	2014-09-03 23:06:29.000000000 +0800
@@ -72,5 +72,5 @@ endif
 
 # needed for relocation
 ifndef CONFIG_NAND_SPL
-LDFLAGS_u-boot += -pie
+#LDFLAGS_u-boot += -pie
 endif
diff -aurNp u-boot-2012.04.01/arch/arm/cpu/arm920t/start.S u-boot-2012.04.01_logo/arch/arm/cpu/arm920t/start.S
--- u-boot-2012.04.01/arch/arm/cpu/arm920t/start.S	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/arch/arm/cpu/arm920t/start.S	2014-09-06 00:28:06.000000000 +0800
@@ -27,7 +27,13 @@
 #include <asm-offsets.h>
 #include <common.h>
 #include <config.h>
-
+#define pWTCON	0x53000000
+#define INTMSK	0x4A000008	/* Interrupt-Controller base addresses */
+#define INTSUBMSK	0x4A00001C
+#define CLKDIVN	0x4C000014	/* clock divisor register */
+#define MPLLCON 0x4c000004
+#define OUTPUT_405MHZ ((0x7f<<12)|(0x02<<4)|(0x1<<0))
+#define OUTPUT_400MHZ ((0x5c<<12)|(0x01<<4)|(0x1<<0))
 /*
  *************************************************************************
  *
@@ -36,7 +42,6 @@
  *************************************************************************
  */
 
-
 .globl _start
 _start:	b	start_code
 	ldr	pc, _undefined_instruction
@@ -57,7 +62,6 @@ _fiq:			.word fiq
 
 	.balignl 16,0xdeadbeef
 
-
 /*
  *************************************************************************
  *
@@ -70,7 +74,6 @@ _fiq:			.word fiq
  *
  *************************************************************************
  */
-
 .globl _TEXT_BASE
 _TEXT_BASE:
 	.word	CONFIG_SYS_TEXT_BASE
@@ -110,10 +113,12 @@ FIQ_STACK_START:
 IRQ_STACK_START_IN:
 	.word	0x0badc0de
 
+.globl base_sp
+base_sp:
+	.long 0
 /*
  * the actual start code
  */
-
 start_code:
 	/*
 	 * set the cpu to SVC32 mode
@@ -123,55 +128,41 @@ start_code:
 	orr	r0, r0, #0xd3
 	msr	cpsr, r0
 
-#if	defined(CONFIG_AT91RM9200DK) || defined(CONFIG_AT91RM9200EK)
-	/*
-	 * relocate exception table
-	 */
-	ldr	r0, =_start
-	ldr	r1, =0x0
-	mov	r2, #16
-copyex:
-	subs	r2, r2, #1
-	ldr	r3, [r0], #4
-	str	r3, [r1], #4
-	bne	copyex
-#endif
-
 #ifdef CONFIG_S3C24X0
-	/* turn off the watchdog */
-
-# if defined(CONFIG_S3C2400)
-#  define pWTCON	0x15300000
-#  define INTMSK	0x14400008	/* Interrupt-Controller base addresses */
-#  define CLKDIVN	0x14800014	/* clock divisor register */
-#else
-#  define pWTCON	0x53000000
-#  define INTMSK	0x4A000008	/* Interrupt-Controller base addresses */
-#  define INTSUBMSK	0x4A00001C
-#  define CLKDIVN	0x4C000014	/* clock divisor register */
-# endif
 
+	/* turn off the watchdog */
 	ldr	r0, =pWTCON
 	mov	r1, #0x0
 	str	r1, [r0]
 
-	/*
-	 * mask all IRQs by setting all bits in the INTMR - default
-	 */
+	/* mask all IRQs by setting all bits in the INTMR - default */
 	mov	r1, #0xffffffff
 	ldr	r0, =INTMSK
 	str	r1, [r0]
-# if defined(CONFIG_S3C2410)
-	ldr	r1, =0x3ff
-	ldr	r0, =INTSUBMSK
-	str	r1, [r0]
-# endif
 
-	/* FCLK:HCLK:PCLK = 1:2:4 */
-	/* default FCLK is 120 MHz ! */
-	ldr	r0, =CLKDIVN
-	mov	r1, #3
-	str	r1, [r0]
+	/* FCLK : HCLK : PCKL = 1 : 4 : 8 */
+	ldr r0, =CLKDIVN
+	mov r1, #0x05            	            
+	str r1, [r0]
+
+	/* 
+	 * If HDIVN is not 0, the CPU bus mode has to be changed 
+	 * from the fast bus mode to the asynchronous 
+	 */
+    mrc    p15, 0, r1, c1, c0, 0        /* read control register */ 
+    orr    r1, r1, #0xc0000000          /* set asynchronous bus mode */
+    mcr    p15, 0, r1, c1, c0, 0        /* write control register */
+
+	/* UPLL should set before MPLL if needed */
+	/* Output Frequency set to 400MHz */
+	ldr r0, =MPLLCON
+	ldr r1, =OUTPUT_400MHZ
+	str r1, [r0]
+
+	mrc p15, 0, r0, c1, c0, 0 @ read control reg
+	orr r0, r0, #(1<<12)
+	mcr p15, 0, r0, c1, c0, 0 @ write it back
+
 #endif	/* CONFIG_S3C24X0 */
 
 	/*
@@ -182,136 +173,29 @@ copyex:
 	bl	cpu_init_crit
 #endif
 
+	ldr sp, = CONFIG_SYS_INIT_SP_ADDR 
+	bic sp, sp, #7
+	
+	bl nand_init_ll
+	
+	mov r0, #0
+	ldr r1, _TEXT_BASE
+	ldr r2, _bss_start_ofs
+
+	bl copy_code_to_sdram
+	bl clear_bss
+
+	ldr pc, =call_board_init_f
 /* Set stackpointer in internal RAM to call board_init_f */
 call_board_init_f:
-	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)
-	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */
 	ldr	r0,=0x00000000
 	bl	board_init_f
 
-/*------------------------------------------------------------------------------*/
-
-/*
- * void relocate_code (addr_sp, gd, addr_moni)
- *
- * This "function" does not return, instead it continues in RAM
- * after relocating the monitor code.
- *
- */
-	.globl	relocate_code
-relocate_code:
-	mov	r4, r0	/* save addr_sp */
-	mov	r5, r1	/* save addr of gd */
-	mov	r6, r2	/* save addr of destination */
-
-	/* Set up the stack						    */
-stack_setup:
-	mov	sp, r4
-
-	adr	r0, _start
-	cmp	r0, r6
-	beq	clear_bss		/* skip relocation */
-	mov	r1, r6			/* r1 <- scratch for copy_loop */
-	ldr	r3, _bss_start_ofs
-	add	r2, r0, r3		/* r2 <- source end address	    */
-
-copy_loop:
-	ldmia	r0!, {r9-r10}		/* copy from source address [r0]    */
-	stmia	r1!, {r9-r10}		/* copy to   target address [r1]    */
-	cmp	r0, r2			/* until source end address [r2]    */
-	blo	copy_loop
-
-#ifndef CONFIG_SPL_BUILD
-	/*
-	 * fix .rel.dyn relocations
-	 */
-	ldr	r0, _TEXT_BASE		/* r0 <- Text base */
-	sub	r9, r6, r0		/* r9 <- relocation offset */
-	ldr	r10, _dynsym_start_ofs	/* r10 <- sym table ofs */
-	add	r10, r10, r0		/* r10 <- sym table in FLASH */
-	ldr	r2, _rel_dyn_start_ofs	/* r2 <- rel dyn start ofs */
-	add	r2, r2, r0		/* r2 <- rel dyn start in FLASH */
-	ldr	r3, _rel_dyn_end_ofs	/* r3 <- rel dyn end ofs */
-	add	r3, r3, r0		/* r3 <- rel dyn end in FLASH */
-fixloop:
-	ldr	r0, [r2]		/* r0 <- location to fix up, IN FLASH! */
-	add	r0, r0, r9		/* r0 <- location to fix up in RAM */
-	ldr	r1, [r2, #4]
-	and	r7, r1, #0xff
-	cmp	r7, #23			/* relative fixup? */
-	beq	fixrel
-	cmp	r7, #2			/* absolute fixup? */
-	beq	fixabs
-	/* ignore unknown type of fixup */
-	b	fixnext
-fixabs:
-	/* absolute fix: set location to (offset) symbol value */
-	mov	r1, r1, LSR #4		/* r1 <- symbol index in .dynsym */
-	add	r1, r10, r1		/* r1 <- address of symbol in table */
-	ldr	r1, [r1, #4]		/* r1 <- symbol value */
-	add	r1, r1, r9		/* r1 <- relocated sym addr */
-	b	fixnext
-fixrel:
-	/* relative fix: increase location by offset */
-	ldr	r1, [r0]
-	add	r1, r1, r9
-fixnext:
-	str	r1, [r0]
-	add	r2, r2, #8		/* each rel.dyn entry is 8 bytes */
-	cmp	r2, r3
-	blo	fixloop
-#endif
-
-clear_bss:
-#ifndef CONFIG_SPL_BUILD
-	ldr	r0, _bss_start_ofs
-	ldr	r1, _bss_end_ofs
-	mov	r4, r6			/* reloc addr */
-	add	r0, r0, r4
-	add	r1, r1, r4
-	mov	r2, #0x00000000		/* clear			    */
-
-clbss_l:str	r2, [r0]		/* clear loop...		    */
-	add	r0, r0, #4
-	cmp	r0, r1
-	bne	clbss_l
-
-	bl coloured_LED_init
-	bl red_led_on
-#endif
-
-/*
- * We are done. Do not return, instead branch to second part of board
- * initialization, now running from RAM.
- */
-#ifdef CONFIG_NAND_SPL
-	ldr     r0, _nand_boot_ofs
-	mov	pc, r0
+	ldr r1, _TEXT_BASE
 
-_nand_boot_ofs:
-	.word nand_boot
-#else
-	ldr	r0, _board_init_r_ofs
-	adr	r1, _start
-	add	lr, r0, r1
-	add	lr, lr, r9
-	/* setup parameters for board_init_r */
-	mov	r0, r5		/* gd_t */
-	mov	r1, r6		/* dest_addr */
-	/* jump to it ... */
-	mov	pc, lr
-
-_board_init_r_ofs:
-	.word board_init_r - _start
-#endif
-
-_rel_dyn_start_ofs:
-	.word __rel_dyn_start - _start
-_rel_dyn_end_ofs:
-	.word __rel_dyn_end - _start
-_dynsym_start_ofs:
-	.word __dynsym_start - _start
+	ldr sp, base_sp
 
+	bl board_init_r
 /*
  *************************************************************************
  *
@@ -322,8 +206,6 @@ _dynsym_start_ofs:
  *
  *************************************************************************
  */
-
-
 #ifndef CONFIG_SKIP_LOWLEVEL_INIT
 cpu_init_crit:
 	/*
diff -aurNp u-boot-2012.04.01/arch/arm/cpu/u-boot.lds u-boot-2012.04.01_logo/arch/arm/cpu/u-boot.lds
--- u-boot-2012.04.01/arch/arm/cpu/u-boot.lds	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/arch/arm/cpu/u-boot.lds	2014-09-03 23:06:29.000000000 +0800
@@ -35,6 +35,7 @@ SECTIONS
 	{
 		__image_copy_start = .;
 		CPUDIR/start.o (.text)
+		board/samsung/mini2440/libmini2440.o (.text)
 		*(.text)
 	}
 
diff -aurNp u-boot-2012.04.01/arch/arm/lib/board.c u-boot-2012.04.01_logo/arch/arm/lib/board.c
--- u-boot-2012.04.01/arch/arm/lib/board.c	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/arch/arm/lib/board.c	2014-09-06 07:50:04.000000000 +0800
@@ -256,12 +256,13 @@ init_fnc_t *init_sequence[] = {
 	NULL,
 };
 
-void board_init_f(ulong bootflag)
+unsigned int board_init_f(ulong bootflag)
 {
 	bd_t *bd;
 	init_fnc_t **init_fnc_ptr;
 	gd_t *id;
 	ulong addr, addr_sp;
+	extern ulong base_sp;
 #ifdef CONFIG_PRAM
 	ulong reg;
 #endif
@@ -369,8 +370,7 @@ void board_init_f(ulong bootflag)
 	 * reserve memory for U-Boot code, data & bss
 	 * round down to next 4 kB limit
 	 */
-	addr -= gd->mon_len;
-	addr &= ~(4096 - 1);
+	addr = CONFIG_SYS_TEXT_BASE;
 
 	debug("Reserving %ldk for U-Boot at: %08lx\n", gd->mon_len >> 10, addr);
 
@@ -417,6 +417,7 @@ void board_init_f(ulong bootflag)
 	gd->irq_sp = addr_sp;
 #endif
 
+	base_sp = addr_sp;
 	debug("New Stack Pointer is: %08lx\n", addr_sp);
 
 #ifdef CONFIG_POST
@@ -435,8 +436,7 @@ void board_init_f(ulong bootflag)
 	debug("relocation Offset is: %08lx\n", gd->reloc_off);
 	memcpy(id, (void *)gd, sizeof(gd_t));
 
-	relocate_code(addr_sp, id, addr);
-
+	return (unsigned int)id;
 	/* NOTREACHED - relocate_code() does not return */
 }
 
@@ -469,9 +469,6 @@ void board_init_r(gd_t *id, ulong dest_a
 
 	monitor_flash_len = _end_ofs;
 
-	/* Enable caches */
-	enable_caches();
-
 	debug("monitor flash len: %08lX\n", monitor_flash_len);
 	board_init();	/* Setup chipselects */
 	/*
@@ -524,8 +521,7 @@ void board_init_r(gd_t *id, ulong dest_a
 		print_size(flash_size, "\n");
 # endif /* CONFIG_SYS_FLASH_CHECKSUM */
 	} else {
-		puts(failed);
-		hang();
+		puts("0KB\n");
 	}
 #endif
 
@@ -647,6 +643,8 @@ void board_init_r(gd_t *id, ulong dest_a
 	}
 #endif
 
+	run_command("mtdparts default", 0);
+
 	/* main_loop() can return to retry autoboot, if so just run it again. */
 	for (;;) {
 		main_loop();
diff -aurNp u-boot-2012.04.01/board/samsung/mini2440/init.c u-boot-2012.04.01_logo/board/samsung/mini2440/init.c
--- u-boot-2012.04.01/board/samsung/mini2440/init.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2012.04.01_logo/board/samsung/mini2440/init.c	2014-09-03 23:06:29.000000000 +0800
@@ -0,0 +1,150 @@
+#define TACLS   0
+#define TWRPH0  1
+#define TWRPH1  0
+
+/* NAND FLASH 控制器*/
+#define NFCONF (*((volatile unsigned long *)0x4E000000))
+#define NFCONT (*((volatile unsigned long *)0x4E000004))
+#define NFCMMD (*((volatile unsigned char *)0x4E000008))
+#define NFADDR (*((volatile unsigned char *)0x4E00000C))
+#define NFDATA (*((volatile unsigned char *)0x4E000010))
+#define NFSTAT (*((volatile unsigned char *)0x4E000020))
+
+
+void nand_read_ll(unsigned int addr, unsigned char *buf, unsigned int len);
+static int isBootFromNorFlash(void)
+{
+	volatile int *p = (volatile int*)0;
+	int val;
+
+	val = *p;
+	*p = 0x12345678;
+	if (*p == 0x12345678)
+	{
+		/* 写成功,是NAND启动 */
+		*p = val;
+		return 0;
+	}
+	else
+	{
+		/* NOR不能像内存一样写 */
+		return 1;
+	}
+}
+
+void copy_code_to_sdram(unsigned char *src, unsigned char *dest, unsigned int len)
+{
+	int i = 0;
+	/* 如果是NOR启动 */
+	if (isBootFromNorFlash())
+	{
+		while (i < len)
+		{
+			dest[i] = src[i];
+			i++;
+		}
+	}
+	else
+	{
+		nand_read_ll((unsigned int)src, dest, len);
+	}
+}
+
+void clear_bss(void)
+{
+	extern int __bss_start, __bss_end__;
+	int *p = &__bss_start;
+
+	for(; p < &__bss_end__; p++)
+		*p = 0;
+}
+
+void nand_init_ll(void)
+{
+	/* 设置时序 */
+    NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
+    /* 使能NAND Flash控制器, 初始化ECC, 禁止片选 */
+    NFCONT = (1<<4)|(1<<1)|(1<<0);
+}
+
+static void nand_select(void)
+{
+	NFCONT &= ~(1<<1);
+}
+
+static void nand_deselect(void)
+{
+	NFCONT |= (1<<1);
+}
+
+static void nand_cmd(unsigned char cmd)
+{	
+	volatile int i;
+	NFCMMD = cmd;
+	for (i = 0; i < 10; i++);
+}
+
+static void nand_addr(unsigned int addr)
+{
+	unsigned int col  = addr % 2048;
+	unsigned int page = addr / 2048;
+	volatile int i;
+
+	NFADDR = col & 0xff;
+	for (i = 0; i < 10; i++);
+	NFADDR = (col >> 8) & 0xff;
+	for (i = 0; i < 10; i++);
+	
+	NFADDR = page & 0xff;
+	for (i = 0; i < 10; i++);
+	NFADDR = (page >> 8) & 0xff;
+	for (i = 0; i < 10; i++);
+	NFADDR = (page >> 16) & 0xff;
+	for (i = 0; i < 10; i++);
+}
+
+static void nand_wait_ready(void)
+{
+	while (!(NFSTAT & 1));
+}
+
+static unsigned char nand_data(void)
+{
+	return NFDATA;
+}
+
+void nand_read_ll(unsigned int addr, unsigned char *buf, unsigned int len)
+{
+	int col = addr % 2048;
+	int i = 0;
+	/* 1. 选中 */ 
+	nand_select();
+	
+	while (i < len)
+	{
+		/* 2. 发出读命令00h */
+		nand_cmd(0x00);
+		
+		/* 3. 发出地址(分5步发出) */
+		nand_addr(addr);
+		
+		/* 4. 发出读命令30h */
+		nand_cmd(0x30);
+		
+		/* 5. 判断状态 */
+		nand_wait_ready();
+		
+		/* 6. 读数据 */
+		for (; (col < 2048) &&(i < len); col++)
+		{
+			buf[i] = nand_data();
+			i++;
+			addr++;
+		}
+
+		col = 0;
+	}
+
+	/* 7. 取消选中 */
+	nand_deselect();
+}
diff -aurNp u-boot-2012.04.01/board/samsung/mini2440/lowlevel_init.S u-boot-2012.04.01_logo/board/samsung/mini2440/lowlevel_init.S
--- u-boot-2012.04.01/board/samsung/mini2440/lowlevel_init.S	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2012.04.01_logo/board/samsung/mini2440/lowlevel_init.S	2014-09-04 00:47:22.000000000 +0800
@@ -0,0 +1,167 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+
+/* some parameters for the board */
+
+/*
+ *
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
+ *
+ * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
+ *
+ */
+
+#define BWSCON	0x48000000
+
+/* BWSCON */
+#define DW8			(0x0)
+#define DW16			(0x1)
+#define DW32			(0x2)
+#define WAIT			(0x1<<2)
+#define UBLB			(0x1<<3)
+
+#define B1_BWSCON		(DW32)
+#define B2_BWSCON		(DW16)
+#define B3_BWSCON		(DW16 + WAIT + UBLB)
+#define B4_BWSCON		(DW16)
+#define B5_BWSCON		(DW16)
+#define B6_BWSCON		(DW32)
+#define B7_BWSCON		(DW32)
+
+/* BANK0CON */
+#define B0_Tacs			0x0	/*  0clk */
+#define B0_Tcos			0x0	/*  0clk */
+#define B0_Tacc			0x7	/* 14clk */
+#define B0_Tcoh			0x0	/*  0clk */
+#define B0_Tah			0x0	/*  0clk */
+#define B0_Tacp			0x0
+#define B0_PMC			0x0	/* normal */
+
+/* BANK1CON */
+#define B1_Tacs			0x0	/*  0clk */
+#define B1_Tcos			0x0	/*  0clk */
+#define B1_Tacc			0x7	/* 14clk */
+#define B1_Tcoh			0x0	/*  0clk */
+#define B1_Tah			0x0	/*  0clk */
+#define B1_Tacp			0x0
+#define B1_PMC			0x0
+
+#define B2_Tacs			0x0
+#define B2_Tcos			0x0
+#define B2_Tacc			0x7
+#define B2_Tcoh			0x0
+#define B2_Tah			0x0
+#define B2_Tacp			0x0
+#define B2_PMC			0x0
+
+#define B3_Tacs			0x0	/*  0clk */
+#define B3_Tcos			0x3	/*  4clk */
+#define B3_Tacc			0x7	/* 14clk */
+#define B3_Tcoh			0x1	/*  1clk */
+#define B3_Tah			0x0	/*  0clk */
+#define B3_Tacp			0x3     /*  6clk */
+#define B3_PMC			0x0	/* normal */
+
+#define B4_Tacs			0x0	/*  0clk */
+#define B4_Tcos			0x0	/*  0clk */
+#define B4_Tacc			0x7	/* 14clk */
+#define B4_Tcoh			0x0	/*  0clk */
+#define B4_Tah			0x0	/*  0clk */
+#define B4_Tacp			0x0
+#define B4_PMC			0x0	/* normal */
+
+#define B5_Tacs			0x0	/*  0clk */
+#define B5_Tcos			0x0	/*  0clk */
+#define B5_Tacc			0x7	/* 14clk */
+#define B5_Tcoh			0x0	/*  0clk */
+#define B5_Tah			0x0	/*  0clk */
+#define B5_Tacp			0x0
+#define B5_PMC			0x0	/* normal */
+
+#define B6_MT			0x3	/* SDRAM */
+#define B6_Trcd			0x1
+#define B6_SCAN			0x1	/* 9bit */
+
+#define B7_MT			0x3	/* SDRAM */
+#define B7_Trcd			0x1	/* 3clk */
+#define B7_SCAN			0x1	/* 9bit */
+
+/* REFRESH parameter */
+#define REFEN			0x1	/* Refresh enable */
+#define TREFMD			0x0	/* CBR(CAS before RAS)/Auto refresh */
+#define Trp			0x0	/* 2clk */
+#define Trc			0x3	/* 7clk */
+#define Tchr			0x2	/* 3clk */
+#define REFCNT			1113	/* period=15.6us, HCLK=60Mhz, (2048+1-15.6*60) */
+/**************************************/
+
+_TEXT_BASE:
+	.word	CONFIG_SYS_TEXT_BASE
+
+.globl lowlevel_init
+lowlevel_init:
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #13*4
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+SMRDATA:
+   	.long 0x22011110     //BWSCON
+	.long 0x00000700     //BANKCON0
+	.long 0x00000700     //BANKCON1
+	.long 0x00000700     //BANKCON2
+	.long 0x00000700     //BANKCON3  
+	.long 0x00000740     //BANKCON4
+	.long 0x00000700     //BANKCON5
+	.long 0x00018005     //BANKCON6
+	.long 0x00018005     //BANKCON7
+	.long 0x008C04F4     //REFRESH
+	.long 0x000000B1     //BANKSIZE
+	.long 0x00000030     //MRSRB6
+	.long 0x00000030     //MRSRB7
diff -aurNp u-boot-2012.04.01/board/samsung/mini2440/Makefile u-boot-2012.04.01_logo/board/samsung/mini2440/Makefile
--- u-boot-2012.04.01/board/samsung/mini2440/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2012.04.01_logo/board/samsung/mini2440/Makefile	2014-09-03 23:38:12.000000000 +0800
@@ -0,0 +1,45 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	:= mini2440.o init.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -aurNp u-boot-2012.04.01/board/samsung/mini2440/mini2440.c u-boot-2012.04.01_logo/board/samsung/mini2440/mini2440.c
--- u-boot-2012.04.01/board/samsung/mini2440/mini2440.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2012.04.01_logo/board/samsung/mini2440/mini2440.c	2014-09-30 17:32:59.000000000 +0800
@@ -0,0 +1,134 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002, 2010
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <asm/arch/s3c24x0_cpu.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define FCLK_SPEED 1
+
+#if FCLK_SPEED==0		/* Fout = 203MHz, Fin = 12MHz for Audio */
+#define M_MDIV	0xC3
+#define M_PDIV	0x4
+#define M_SDIV	0x1
+#elif FCLK_SPEED==1		/* Fout = 202.8MHz */
+#define M_MDIV	0xA1
+#define M_PDIV	0x3
+#define M_SDIV	0x1
+#endif
+
+#define USB_CLOCK 1
+
+#if USB_CLOCK==0
+#define U_M_MDIV	0xA1
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x1
+#elif USB_CLOCK==1
+#define U_M_MDIV	0x48
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x2
+#endif
+
+static inline void pll_delay(unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+	  "subs %0, %1, #1\n"
+	  "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_early_init_f(void)
+{
+	struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();
+
+	/* set up the I/O ports */
+	writel(0x007FFFFF, &gpio->gpacon);
+	writel(0x00044555, &gpio->gpbcon);
+	writel(0x000007FF, &gpio->gpbup);
+	writel(0xAAAAAAAA, &gpio->gpccon);
+	writel(0x0000FFFF, &gpio->gpcup);
+	writel(0xAAAAAAAA, &gpio->gpdcon);
+	writel(0x0000FFFF, &gpio->gpdup);
+	writel(0xAAAAAAAA, &gpio->gpecon);
+	writel(0x0000FFFF, &gpio->gpeup);
+	writel(0x000055AA, &gpio->gpfcon);
+	writel(0x000000FF, &gpio->gpfup);
+	writel(0xFF95FFBA, &gpio->gpgcon);
+	writel(0x0000FFFF, &gpio->gpgup);
+	writel(0x002AFAAA, &gpio->gphcon);
+	writel(0x000007FF, &gpio->gphup);
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* arch number of SMDK2410-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_SMDK2410;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x30000100;
+
+	icache_enable();
+	dcache_enable();
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	/* dram_init must store complete ramsize in gd->ram_size */
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+#ifdef CONFIG_CMD_NET
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+	rc = dm9000_initialize(bis);
+	return rc;
+}
+#endif
+
+/*
+ * Hardcoded flash setup:
+ * Flash 0 is a non-CFI AMD AM29LV800BB flash.
+ */
+ulong board_flash_get_legacy(ulong base, int banknum, flash_info_t *info)
+{
+	info->portwidth = FLASH_CFI_16BIT;
+	info->chipwidth = FLASH_CFI_BY16;
+	info->interface = FLASH_CFI_X16;
+	return 1;
+}
diff -aurNp u-boot-2012.04.01/boards.cfg u-boot-2012.04.01_logo/boards.cfg
--- u-boot-2012.04.01/boards.cfg	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/boards.cfg	2014-09-03 23:06:29.000000000 +0800
@@ -63,6 +63,7 @@ cm4008                       arm        
 cm41xx                       arm         arm920t     -                   -              ks8695
 VCMA9                        arm         arm920t     vcma9               mpl            s3c24x0
 smdk2410                     arm         arm920t     -                   samsung        s3c24x0
+mini2440                     arm         arm920t     -                   samsung        s3c24x0
 omap1510inn                  arm         arm925t     -                   ti
 integratorap_cm926ejs        arm         arm926ejs   integrator          armltd         -           integratorap:CM926EJ_S
 integratorcp_cm926ejs        arm         arm926ejs   integrator          armltd         -           integratorcp:CM924EJ_S
diff -aurNp u-boot-2012.04.01/drivers/mtd/jedec_flash.c u-boot-2012.04.01_logo/drivers/mtd/jedec_flash.c
--- u-boot-2012.04.01/drivers/mtd/jedec_flash.c	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/drivers/mtd/jedec_flash.c	2014-09-03 23:06:29.000000000 +0800
@@ -367,6 +367,24 @@ static const struct amd_flash_info jedec
 		}
 	},
 #endif
+	/* mini2440 S29AL016J = Am29LV160D */
+	{  
+        .mfr_id     = (u16)AMD_MANUFACT,
+        .dev_id     = AM29LV160DB,     
+		.name		= "spansion s29al016j",
+        .uaddr      = {
+            [1] = MTD_UADDR_0x0555_0x02AA /* x16 */  
+        },  
+        .DevSize    = SIZE_2MiB,  
+        .CmdSet     = P_ID_AMD_STD,  
+        .NumEraseRegions= 4,  
+        .regions    = {  
+            ERASEINFO(0x04000,1),  /* 6  blocks */  
+            ERASEINFO(0x02000,2), /* 10 blocks */  
+            ERASEINFO(0x08000,1), /* 15 blocks */  
+            ERASEINFO(0x10000,31),  /* 1  blocks */  
+        }  
+    },  
 };
 
 static inline void fill_info(flash_info_t *info, const struct amd_flash_info *jedec_entry, ulong base)
diff -aurNp u-boot-2012.04.01/drivers/mtd/nand/Makefile u-boot-2012.04.01_logo/drivers/mtd/nand/Makefile
--- u-boot-2012.04.01/drivers/mtd/nand/Makefile	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/drivers/mtd/nand/Makefile	2014-09-03 23:21:51.000000000 +0800
@@ -59,6 +59,7 @@ COBJS-$(CONFIG_NAND_MXS) += mxs_nand.o
 COBJS-$(CONFIG_NAND_NDFC) += ndfc.o
 COBJS-$(CONFIG_NAND_NOMADIK) += nomadik.o
 COBJS-$(CONFIG_NAND_S3C2410) += s3c2410_nand.o
+COBJS-$(CONFIG_NAND_S3C2440) += s3c2440_nand.o
 COBJS-$(CONFIG_NAND_S3C64XX) += s3c64xx.o
 COBJS-$(CONFIG_NAND_SPEAR) += spr_nand.o
 COBJS-$(CONFIG_NAND_OMAP_GPMC) += omap_gpmc.o
diff -aurNp u-boot-2012.04.01/drivers/mtd/nand/nand_util.c u-boot-2012.04.01_logo/drivers/mtd/nand/nand_util.c
--- u-boot-2012.04.01/drivers/mtd/nand/nand_util.c	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/drivers/mtd/nand/nand_util.c	2014-09-04 18:43:19.000000000 +0800
@@ -515,7 +515,7 @@ int nand_write_skip_bad(nand_info_t *nan
 		return -EINVAL;
 	}
 
-	if (!need_skip && !(flags & WITH_DROP_FFS)) {
+	if (!need_skip && !(flags & WITH_YAFFS_OOB)) {
 		rval = nand_write (nand, offset, length, buffer);
 		if (rval == 0)
 			return 0;
@@ -553,7 +553,7 @@ int nand_write_skip_bad(nand_info_t *nan
 
 			ops.len = pagesize;
 			ops.ooblen = nand->oobsize;
-			ops.mode = MTD_OOB_AUTO;
+			ops.mode = MTD_OOB_RAW;
 			ops.ooboffs = 0;
 
 			pages = write_size / pagesize_oob;
@@ -564,7 +564,7 @@ int nand_write_skip_bad(nand_info_t *nan
 				ops.oobbuf = ops.datbuf + pagesize;
 
 				rval = nand->write_oob(nand, offset, &ops);
-				if (!rval)
+				if (rval)
 					break;
 
 				offset += pagesize;
diff -aurNp u-boot-2012.04.01/drivers/mtd/nand/s3c2440_nand.c u-boot-2012.04.01_logo/drivers/mtd/nand/s3c2440_nand.c
--- u-boot-2012.04.01/drivers/mtd/nand/s3c2440_nand.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2012.04.01_logo/drivers/mtd/nand/s3c2440_nand.c	2014-09-30 14:23:27.000000000 +0800
@@ -0,0 +1,173 @@
+/*
+ * (C) Copyright 2006 OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#include <nand.h>
+#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/io.h>
+
+#define S3C2410_NFCONF_EN          (1<<15)
+#define S3C2410_NFCONF_512BYTE     (1<<14)
+#define S3C2410_NFCONF_4STEP       (1<<13)
+#define S3C2410_NFCONF_INITECC     (1<<12)
+#define S3C2410_NFCONF_nFCE        (1<<11)
+#define S3C2410_NFCONF_TACLS(x)    ((x)<<8)
+#define S3C2410_NFCONF_TWRPH0(x)   ((x)<<4)
+#define S3C2410_NFCONF_TWRPH1(x)   ((x)<<0)
+
+#define S3C2410_ADDR_NALE 4
+#define S3C2410_ADDR_NCLE 8
+
+#ifdef CONFIG_NAND_SPL
+
+/* in the early stage of NAND flash booting, printf() is not available */
+#define printf(fmt, args...)
+
+static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+
+	for (i = 0; i < len; i++)
+		buf[i] = readb(this->IO_ADDR_R);
+}
+#endif
+
+
+/* ctrl : 表示做什么，选中芯片/取消选中，发命令还是发地址
+ *
+ * dat 	: 命令值或地址值
+ */
+static void s3c2440_hwcontrol(struct mtd_info *mtd, int dat, unsigned int ctrl)
+{
+	struct s3c2440_nand *nand = s3c2440_get_base_nand();
+
+	if (ctrl & NAND_CLE)
+	{
+		/* 发命令 */
+		writeb(dat, &nand->nfcmd);
+	}
+	else if(ctrl & NAND_ALE)
+	{
+		/* 发地址 */
+		writeb(dat, &nand->nfaddr);
+	}
+}
+
+static int s3c2440_dev_ready(struct mtd_info *mtd)
+{
+	struct s3c2440_nand *nand = s3c2440_get_base_nand();
+	//debug("dev_ready\n");
+	return readl(&nand->nfstat) & 0x01;
+}
+
+static void s3c2440_nand_select(struct mtd_info *mtd, int chipnr)
+{
+	struct s3c2440_nand *nand = s3c2440_get_base_nand();
+
+	switch (chipnr) {
+	case -1:	/* 取消选中 */
+		nand->nfcont |= (1<<1);
+		break;
+	case 0:		/* 选中 */
+		nand->nfcont &= ~(1<<1);
+		break;
+
+	default:
+		BUG();
+	}
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	u_int32_t cfg;
+	u_int8_t tacls, twrph0, twrph1;
+	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
+	struct s3c2440_nand *nand_reg = s3c2440_get_base_nand();
+
+	debug("board_nand_init()\n");
+
+	writel(readl(&clk_power->clkcon) | (1 << 4), &clk_power->clkcon);
+
+	/* initialize hardware */
+#if defined(CONFIG_S3C24XX_CUSTOM_NAND_TIMING)
+	tacls  = CONFIG_S3C24XX_TACLS;
+	twrph0 = CONFIG_S3C24XX_TWRPH0;
+	twrph1 =  CONFIG_S3C24XX_TWRPH1;
+#else
+	tacls  = 0;
+	twrph0 = 3;
+	twrph1 = 1;
+#endif
+
+#if 0
+	cfg = S3C2410_NFCONF_EN;
+	cfg |= S3C2410_NFCONF_TACLS(tacls - 1);
+	cfg |= S3C2410_NFCONF_TWRPH0(twrph0 - 1);
+	cfg |= S3C2410_NFCONF_TWRPH1(twrph1 - 1);
+#endif
+
+	/* 初始化时序 */
+	cfg = ((tacls-1)<<12) | ((twrph0-1)<<8) | ((twrph1-1)<<4);
+	writel(cfg, &nand_reg->nfconf);
+
+	/* 使能NAND Flash 控制器，初始化ECC，禁止片选 */
+	cfg = (1<<4)|(1<<1)|(1<<0);
+	writel(cfg, &nand_reg->nfcont);
+
+	/* initialize nand_chip data structure */
+	nand->IO_ADDR_R = (void *)&nand_reg->nfdata;
+	nand->IO_ADDR_W = (void *)&nand_reg->nfdata;
+
+	nand->select_chip = s3c2440_nand_select;
+
+	/* read_buf and write_buf are default */
+	/* read_byte and write_byte are default */
+#ifdef CONFIG_NAND_SPL
+	nand->read_buf = nand_read_buf;
+#endif
+
+	/* hwcontrol always must be implemented */
+	nand->cmd_ctrl = s3c2440_hwcontrol;
+
+	nand->dev_ready = s3c2440_dev_ready;
+
+#ifdef CONFIG_S3C2410_NAND_HWECC
+	nand->ecc.hwctl = s3c2410_nand_enable_hwecc;
+	nand->ecc.calculate = s3c2410_nand_calculate_ecc;
+	nand->ecc.correct = s3c2410_nand_correct_data;
+	nand->ecc.mode = NAND_ECC_HW;
+	nand->ecc.size = CONFIG_SYS_NAND_ECCSIZE;
+	nand->ecc.bytes = CONFIG_SYS_NAND_ECCBYTES;
+#else
+	nand->ecc.mode = NAND_ECC_SOFT;
+#endif
+
+#ifdef CONFIG_S3C2410_NAND_BBT
+	nand->options = NAND_USE_FLASH_BBT;
+#else
+	nand->options = 0;
+#endif
+
+	debug("end of nand_init\n");
+
+	return 0;
+}
diff -aurNp u-boot-2012.04.01/drivers/net/dm9000x.c u-boot-2012.04.01_logo/drivers/net/dm9000x.c
--- u-boot-2012.04.01/drivers/net/dm9000x.c	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/drivers/net/dm9000x.c	2014-09-05 12:15:10.000000000 +0800
@@ -368,16 +368,6 @@ static int dm9000_init(struct eth_device
 	/* Enable TX/RX interrupt mask */
 	DM9000_iow(DM9000_IMR, IMR_PAR);
 
-	i = 0;
-	while (!(dm9000_phy_read(1) & 0x20)) {	/* autonegation complete bit */
-		udelay(1000);
-		i++;
-		if (i == 10000) {
-			printf("could not establish link\n");
-			return 0;
-		}
-	}
-
 	/* see what we've got */
 	lnk = dm9000_phy_read(17) >> 12;
 	printf("operating at ");
@@ -451,12 +441,6 @@ static int dm9000_send(struct eth_device
 static void dm9000_halt(struct eth_device *netdev)
 {
 	DM9000_DBG("%s\n", __func__);
-
-	/* RESET devie */
-	dm9000_phy_write(0, 0x8000);	/* PHY RESET */
-	DM9000_iow(DM9000_GPR, 0x01);	/* Power-Down PHY */
-	DM9000_iow(DM9000_IMR, 0x80);	/* Disable all interrupt */
-	DM9000_iow(DM9000_RCR, 0x00);	/* Disable RX */
 }
 
 /*
diff -aurNp u-boot-2012.04.01/drivers/video/cfb_console.c u-boot-2012.04.01_logo/drivers/video/cfb_console.c
--- u-boot-2012.04.01/drivers/video/cfb_console.c	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/drivers/video/cfb_console.c	2014-09-30 17:30:52.000000000 +0800
@@ -297,8 +297,10 @@ void console_cursor(int state);
 #define VIDEO_LOGO_LUT_OFFSET	LINUX_LOGO_LUT_OFFSET
 #define VIDEO_LOGO_COLORS	LINUX_LOGO_COLORS
 #endif /* CONFIG_VIDEO_BMP_LOGO */
-#define VIDEO_INFO_X		(VIDEO_LOGO_WIDTH)
-#define VIDEO_INFO_Y		(VIDEO_FONT_HEIGHT/2)
+
+#define VIDEO_INFO_X		(0)
+#define VIDEO_INFO_Y		(VIDEO_LOGO_HEIGHT)
+
 #else  /* CONFIG_VIDEO_LOGO */
 #define VIDEO_LOGO_WIDTH	0
 #define VIDEO_LOGO_HEIGHT	0
@@ -1657,7 +1659,10 @@ static int video_init(void)
 
 	pGD = video_hw_init();
 	if (pGD == NULL)
+	{
+		debug("pGd == NULL\n");
 		return -1;
+	}
 
 	video_fb_address = (void *) VIDEO_FB_ADRS;
 #ifdef CONFIG_VIDEO_HW_CURSOR
@@ -1742,6 +1747,7 @@ static int video_init(void)
 #else
 	video_console_address = video_fb_address;
 #endif
+	debug("video_console_address is %08lx\n", video_console_address);
 
 	/* Initialize the console */
 	console_col = 0;
diff -aurNp u-boot-2012.04.01/drivers/video/Makefile u-boot-2012.04.01_logo/drivers/video/Makefile
--- u-boot-2012.04.01/drivers/video/Makefile	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/drivers/video/Makefile	2014-09-21 07:10:33.000000000 +0800
@@ -25,6 +25,8 @@ include $(TOPDIR)/config.mk
 
 LIB	:= $(obj)libvideo.o
 
+COBJS-$(CONFIG_VIDEO_S3C2440) += s3c2440_fb.o videomodes.o cfb_console.o
+
 COBJS-$(CONFIG_ATI_RADEON_FB) += ati_radeon_fb.o videomodes.o
 COBJS-$(CONFIG_ATMEL_LCD) += atmel_lcdfb.o
 COBJS-$(CONFIG_CFB_CONSOLE) += cfb_console.o
diff -aurNp u-boot-2012.04.01/drivers/video/s3c2440_fb.c u-boot-2012.04.01_logo/drivers/video/s3c2440_fb.c
--- u-boot-2012.04.01/drivers/video/s3c2440_fb.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2012.04.01_logo/drivers/video/s3c2440_fb.c	2014-09-30 19:00:00.000000000 +0800
@@ -0,0 +1,147 @@
+#include <common.h>
+#if defined(CONFIG_VIDEO_S3C2440)
+#include <video_fb.h>
+#include "videomodes.h"
+#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/io.h>
+/*
+ * Export Graphic Device
+ */
+GraphicDevice smi;
+#define VIDEO_MEM_SIZE 0x200000
+
+void *video_hw_init (void)
+{
+	struct s3c24x0_lcd * const lcd = s3c24x0_get_base_lcd();
+	struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();
+
+	GraphicDevice *pGD = (GraphicDevice *)&smi;
+	int videomode;
+	int bppmode;
+	unsigned long t1, hsynch, vsynch;
+	char *penv;
+	int tmp, i, bits_per_pixel;
+	struct ctfb_res_modes *res_mode;
+	struct ctfb_res_modes var_mode;
+	tmp = 0;
+	videomode = CONFIG_SYS_DEFAULT_VIDEO_MODE;
+
+	debug("video hardware init\n");
+	/* get video mode via environment */
+	if ((penv = getenv ("videomode")) != NULL) {
+		/* deceide if it is a string */
+		if (penv[0] <= '9') {
+			videomode = (int) simple_strtoul (penv, NULL, 16);
+			tmp = 1;
+		}
+	}
+	else
+	{
+		tmp = 1;
+	}
+
+	if (tmp) {
+		/* parameter are vesa modes */
+		/* search params */
+		for (i = 0; i < VESA_MODES_COUNT; i++) {
+			if (vesa_modes[i].vesanr == videomode)
+				break;
+		}
+		if (i == VESA_MODES_COUNT) {
+			printf ("no VESA Mode found, switching to mode 0x%x ",
+					CONFIG_SYS_DEFAULT_VIDEO_MODE);
+			i = 0;
+		}
+		res_mode  =  (struct  ctfb_res_modes  *)
+			&res_mode_init[vesa_modes[i].resindex];
+		bits_per_pixel = vesa_modes[i].bits_per_pixel;
+	}
+	else
+	{
+		res_mode = (struct ctfb_res_modes *) &var_mode;
+		bits_per_pixel = video_get_params (res_mode, penv);
+	}
+	/* calculate hsynch and vsynch freq (info only) */
+	t1 = (res_mode->left_margin + res_mode->xres + res_mode->right_margin +
+			res_mode->hsync_len) / 8;
+	t1 *= 8;
+	t1 *= res_mode->pixclock;
+	t1 /= 1000;
+	hsynch = 1000000000L / t1;
+	t1 *= (res_mode->upper_margin + res_mode->yres + res_mode->lower_margin +
+			res_mode->vsync_len);
+	t1 /= 1000;
+	vsynch = 1000000000L / t1;
+	/* fill in Graphic device struct */
+	sprintf (pGD->modeIdent, "%dx%dx%d %ldkHz %ldHz", res_mode->xres,
+			res_mode->yres, bits_per_pixel, (hsynch / 1000), (vsynch / 1000));
+
+	switch (bits_per_pixel)
+	{
+		case 8:
+			pGD->gdfBytesPP = 1;
+			pGD->gdfIndex = GDF__8BIT_INDEX;
+			bppmode = 11;
+			break;
+		case 16:
+			pGD->gdfBytesPP = 2;
+			pGD->gdfIndex = GDF_16BIT_565RGB;
+			bppmode = 12;
+			break;
+		case 24:
+			pGD->gdfBytesPP = 3;
+			pGD->gdfIndex = GDF_24BIT_888RGB;
+			bppmode = 13;
+			break;
+	}
+
+	/* statically configure settings */
+	pGD->winSizeX = 240;
+	pGD->plnSizeX = 240;
+	pGD->winSizeY = 320;
+	pGD->plnSizeY = 320;
+	debug("winSizeX = %d\n", pGD->winSizeX);
+	debug("winSizeY = %d\n", pGD->winSizeY);
+	debug("plnSizeX = %d\n", pGD->plnSizeX);
+	debug("plnSizeY = %d\n", pGD->plnSizeY);
+
+	pGD->frameAdrs = LCD_VIDEO_ADDR;
+	pGD->memSize = VIDEO_MEM_SIZE;
+
+	gpio->gpccon = 0xaaaaaaaa;
+	gpio->gpdcon = 0xaaaaaaaa;
+	gpio->gpgcon |= (3<<8);
+
+	lcd->lcdcon1 = (8<<8) | (3<<5) | (0x0c<<1);
+	lcd->lcdcon2 = (0<<24) | (319<<14) | (4<<6) | (9<<0);
+	lcd->lcdcon3 = (25<<19) | (239<<8) | (0<<0);
+	lcd->lcdcon4 = (4<<0);
+	lcd->lcdcon5 = ((0<<11) | (1<<10) | (1<<9) | (1<<8) | (1<<6) | (1<<3) | (1<<0));
+
+	writel((pGD->frameAdrs >> 1), &lcd->lcdsaddr1);
+	debug("lcdsaddr1 = %08x\n", readl(&lcd->lcdsaddr1));
+
+	/* This marks the end of the frame buffer. */
+	writel((((readl(&lcd->lcdsaddr1))&0x1fffff) + (pGD->winSizeX+0)* pGD->winSizeY), &lcd->lcdsaddr2);
+	debug("lcdsaddr2 = %08x\n", readl(&lcd->lcdsaddr2));
+
+	writel((pGD->winSizeY & 0x7ff), &lcd->lcdsaddr3);
+	debug("lcdsaddr3 = %08x\n", readl(&lcd->lcdsaddr3));
+
+	/* Clear video memory */
+	memset((void *)pGD->frameAdrs, 0, pGD->memSize);
+
+	lcd->lcdcon1 |= 0x01;
+	lcd->lcdcon5 |= (1<<3);
+
+	return ((void*)&smi);
+}
+
+void video_set_lut (unsigned int index, /* color number */
+		unsigned char r, /* red */
+		unsigned char g, /* green */
+		unsigned char b /* blue */
+		)
+{
+}
+#endif /* CONFIG_VIDEO_S3C2440 */
diff -aurNp u-boot-2012.04.01/drivers/video/videomodes.c u-boot-2012.04.01_logo/drivers/video/videomodes.c
--- u-boot-2012.04.01/drivers/video/videomodes.c	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/drivers/video/videomodes.c	2014-09-30 17:31:14.000000000 +0800
@@ -98,6 +98,7 @@ const struct ctfb_vesa_modes vesa_modes[
 	{0x319, RES_MODE_1280x1024, 15},
 	{0x31A, RES_MODE_1280x1024, 16},
 	{0x31B, RES_MODE_1280x1024, 24},
+	{0x211, RES_MODE_240x320, 16},
 };
 const struct ctfb_res_modes res_mode_init[RES_MODES_COUNT] = {
 	/* x	 y pixclk   le	ri  up	lo   hs vs  s  vmode */
@@ -107,6 +108,8 @@ const struct ctfb_res_modes res_mode_ini
 	{960, 720, 13100, 160, 40, 32, 8, 80, 4, 0, FB_VMODE_NONINTERLACED},
 	{1152, 864, 12004, 200, 64, 32, 16, 80, 4, 0, FB_VMODE_NONINTERLACED},
 	{1280, 1024, 9090, 200, 48, 26, 1, 184, 3, 0, FB_VMODE_NONINTERLACED},
+	{800, 480, 40000, 40, 40, 13, 29, 48, 3, 0, FB_VMODE_NONINTERLACED},
+	{240, 320, 158025, 26,  6,  1, 11, 37,  2, 0, FB_VMODE_NONINTERLACED},
 };
 
 /************************************************************************
diff -aurNp u-boot-2012.04.01/drivers/video/videomodes.h u-boot-2012.04.01_logo/drivers/video/videomodes.h
--- u-boot-2012.04.01/drivers/video/videomodes.h	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/drivers/video/videomodes.h	2014-09-30 15:31:24.000000000 +0800
@@ -22,8 +22,10 @@
  */
 
 
+//#ifndef CONFIG_SYS_DEFAULT_VIDEO_MODE
+//#define CONFIG_SYS_DEFAULT_VIDEO_MODE	0x213
 #ifndef CONFIG_SYS_DEFAULT_VIDEO_MODE
-#define CONFIG_SYS_DEFAULT_VIDEO_MODE	0x301
+#define CONFIG_SYS_DEFAULT_VIDEO_MODE	0x211
 #endif
 
 /* Some mode definitions */
@@ -78,10 +80,14 @@ struct ctfb_vesa_modes {
 #define RES_MODE_960_720	3
 #define RES_MODE_1152x864	4
 #define RES_MODE_1280x1024	5
-#define RES_MODES_COUNT		6
-
-#define VESA_MODES_COUNT 19
-
+#define RES_MODE_240x320 6
+#define RES_MODES_COUNT  7
+#define VESA_MODES_COUNT 20
+#if 0
+#define RES_MODE_800x480 6
+#define RES_MODES_COUNT 7
+#define VESA_MODES_COUNT  20
+#endif
 extern const struct ctfb_vesa_modes vesa_modes[];
 extern const struct ctfb_res_modes res_mode_init[];
 
diff -aurNp u-boot-2012.04.01/examples/standalone/Makefile u-boot-2012.04.01_logo/examples/standalone/Makefile
--- u-boot-2012.04.01/examples/standalone/Makefile	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/examples/standalone/Makefile	2014-09-05 10:31:21.000000000 +0800
@@ -88,7 +88,8 @@ endif
 CFLAGS_NTR := $(call cc-option,-fno-toplevel-reorder)
 CFLAGS += $(CFLAGS_NTR)
 
-all:	$(obj).depend $(OBJS) $(LIB) $(SREC) $(BIN) $(ELF)
+#all:	$(obj).depend $(OBJS) $(LIB) $(SREC) $(BIN) $(ELF)
+all:
 
 #########################################################################
 $(LIB):	$(obj).depend $(LIBOBJS)
diff -aurNp u-boot-2012.04.01/include/common.h u-boot-2012.04.01_logo/include/common.h
--- u-boot-2012.04.01/include/common.h	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/include/common.h	2014-09-03 23:06:29.000000000 +0800
@@ -273,7 +273,7 @@ int	abortboot(int bootdelay);
 extern char console_buffer[];
 
 /* arch/$(ARCH)/lib/board.c */
-void	board_init_f  (ulong) __attribute__ ((noreturn));
+unsigned int	board_init_f  (ulong);
 void	board_init_r  (gd_t *, ulong) __attribute__ ((noreturn));
 int	checkboard    (void);
 int	checkflash    (void);
diff -aurNp u-boot-2012.04.01/include/configs/mini2440.h u-boot-2012.04.01_logo/include/configs/mini2440.h
--- u-boot-2012.04.01/include/configs/mini2440.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2012.04.01_logo/include/configs/mini2440.h	2014-09-30 18:19:59.000000000 +0800
@@ -0,0 +1,217 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Gary Jennejohn <garyj@denx.de>
+ * David Mueller <d.mueller@elsoft.ch>
+ *
+ * Configuation settings for the SAMSUNG SMDK2410 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM920T		/* This is an ARM920T Core */
+#define CONFIG_S3C24X0		/* in a SAMSUNG S3C24x0-type SoC */
+#define CONFIG_S3C2440		/* specifically a SAMSUNG S3C2410 SoC */
+
+/* undefine will cuz unbootable mark by 0way */
+#define CONFIG_SYS_ARM_CACHE_WRITETHROUGH 
+
+#define CONFIG_SYS_TEXT_BASE	0x33f80000
+
+/* input clock of PLL (the SMDK2410 has 12MHz input clock) */
+#define CONFIG_SYS_CLK_FREQ	12000000
+
+#undef CONFIG_USE_IRQ		/* we don't need IRQ/FIQ stuff */
+
+#define CONFIG_CMDLINE_TAG	/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_DRIVER_DM9000 1
+#define CONFIG_NET_RETRY_COUNT 20
+#define CONFIG_DM9000_BASE  0x20000300
+#define DM9000_IO       CONFIG_DM9000_BASE
+#define DM9000_DATA     (CONFIG_DM9000_BASE + 4)
+#define CONFIG_DM9000_NO_SROM	1
+/*
+ * select serial console configuration
+ */
+#define CONFIG_S3C24X0_SERIAL
+#define CONFIG_SERIAL1		1	/* we use SERIAL 1 on SMDK2410 */
+
+#define CONFIG_BAUDRATE		115200
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NAND
+
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_CMDLINE_EDITING
+
+/* autoboot */
+#define CONFIG_BOOTDELAY	5
+//#define CONFIG_BOOT_RETRY_TIME	-1
+#define CONFIG_RESET_TO_RETRY
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_NETMASK		255.255.255.0
+#define CONFIG_IPADDR		192.168.1.123
+#define CONFIG_SERVERIP		192.168.1.100
+#define CONFIG_ETHADDR		00:0c:29:4d:e4:f4
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_PROMPT	"uboot > "
+#define CONFIG_SYS_CBSIZE	256
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE + \
+				sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS	16
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE
+
+#define CONFIG_DISPLAY_CPUINFO				/* Display cpu info */
+
+#define CONFIG_SYS_MEMTEST_START	0x30000000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x33F00000	/* 63 MB in DRAM */
+
+#define CONFIG_SYS_LOAD_ADDR		0x30800000
+
+#define CONFIG_SYS_HZ			1000
+
+/* valid baudrates */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* Yaffs Command */
+#define CONFIG_CMD_NAND_YAFFS
+
+#define CONFIG_BOOTARGS "console=ttySAC0,115200 root=/dev/mtdblock3 init=/linuxrc"
+#define CONFIG_BOOTCOMMAND "nand read 30000000 kernel ; bootm 30000000"
+/*
+ * Stack sizes
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1          /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x30000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #0 */
+
+#define CONFIG_SYS_FLASH_BASE	PHYS_FLASH_1
+
+/*
+ * FLASH and environment organization
+ */
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_FLASH_CFI_LEGACY
+#define CONFIG_SYS_FLASH_LEGACY_512Kx16
+#define CONFIG_FLASH_SHOW_PROGRESS	45
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_FLASH_BANKS_LIST     { CONFIG_SYS_FLASH_BASE }
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)
+
+/* env */
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_OFFSET		0x40000
+#define CONFIG_ENV_SIZE			0x20000
+#define CONFIG_ENV_RANGE		0x20000
+
+/* mtd */
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_MTD_DEVICE
+#define MTDIDS_DEFAULT		"nand0=mini2440-0"
+#define MTDPARTS_DEFAULT 	"mtdparts=mini2440-0:256k(u-boot),"	\
+							"128k(params),"	\
+							"2m(kernel),"	\
+							"-(rootfs)"		\
+/*
+ * Size of malloc() pool
+ * BZIP2 / LZO / LZMA need a lot of RAM
+ */
+#define CONFIG_SYS_MALLOC_LEN	(4 * 1024 * 1024)
+
+#define CONFIG_SYS_MONITOR_LEN	(448 * 1024)
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_FLASH_BASE
+
+/*
+ * NAND configuration
+ */
+#ifdef CONFIG_CMD_NAND
+#define CONFIG_NAND_S3C2440
+//#define CONFIG_SYS_S3C2440_NAND_HWECC
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x4E000000
+#endif
+
+/* additions for new relocation code, must be added to all boards */
+#define CONFIG_SYS_SDRAM_BASE	PHYS_SDRAM_1
+#define CONFIG_SYS_INIT_SP_ADDR	(CONFIG_SYS_SDRAM_BASE + 0x1000 - \
+				GENERATED_GBL_DATA_SIZE)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+
+/* LCD settings */
+//#define CONFIG_LCD	1
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_S3C2440
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO /* show denx logo undef will show pingo */
+#define VIDEO_FB_16BPP_PIXEL_SWAP 
+#define CONFIG_VIDEO_SW_CURSOR 
+#define VIDEO_FB_16BPP_WORD_SWAP
+#define CONFIG_SYS_VIDEO_LOGO_MAX_SIZE (800*480+1024+100)
+#define LCD_VIDEO_ADDR 0x33d00000
+#define CONFIG_CMD_BMP
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SYS_CONSOLE_INFO_QUIET
+/* for PC-keyboard */
+#define VIDEO_KBD_INIT_FCT 0
+#define VIDEO_TSTC_FCT serial_tstc
+#define VIDEO_GETC_FCT serial_getc
+
+//#define DEBUG
+//#define CONFIG_OF_LIBFDT	1
+#endif /* __CONFIG_H */
diff -aurNp u-boot-2012.04.01/tools/logos/jp_2_bmp.sh u-boot-2012.04.01_logo/tools/logos/jp_2_bmp.sh
--- u-boot-2012.04.01/tools/logos/jp_2_bmp.sh	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2012.04.01_logo/tools/logos/jp_2_bmp.sh	2014-09-30 18:18:31.000000000 +0800
@@ -0,0 +1,3 @@
+#!/bin/sh
+#install Netpbm first
+jpegtopnm $1 | ppmquant 31 | ppmtobmp -bpp 8 > $2
diff -aurNp u-boot-2012.04.01/tools/Makefile u-boot-2012.04.01_logo/tools/Makefile
--- u-boot-2012.04.01/tools/Makefile	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_logo/tools/Makefile	2014-09-30 18:47:38.000000000 +0800
@@ -124,7 +124,8 @@ LOGO-$(CONFIG_VIDEO_LOGO) += $(LOGO_H)
 LOGO-$(CONFIG_VIDEO_LOGO) += $(LOGO_DATA_H)
 
 ifeq ($(LOGO_BMP),)
-LOGO_BMP= logos/denx.bmp
+LOGO_BMP= logos/bsd.bmp
+#LOGO_BMP= logos/denx.bmp
 endif
 ifeq ($(VENDOR),atmel)
 LOGO_BMP= logos/atmel.bmp
